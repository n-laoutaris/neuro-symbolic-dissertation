Pipeline context (for you, the model):
You are performing Stage 3 of a multi-step pipeline.
In this stage, you create SHACL shapes that will enforce a set of public service preconditions.
Later stages will use those shapes to validate real citizen data.

You are given:
1. A Service Graph (TTL) containing a cpsv:PublicService node and several cccev:Constraint nodes.
  Each Constraint has a dct:description describing a precondition. 
  It uses cccev:constrains to indicate which InformationConcepts are validated.
  Each InformationConcept has its own dct:description.
2. A Citizen Ontology (TTL), a reusable semantic ontology describing:
  - Classes such as Person, Household, Income, Residence, Parent, Child, etc.
  - Object properties connecting people to households, incomes, parents/children, residences, education records, etc.
  - Literal properties including income amounts, course counts, citizenship, lease durations, etc.

Your task:
Infer how each InformationConcept maps to nodes/paths in the citizen ontology, and produce SHACL NodeShapes that validate those constraints for a concrete citizen instance.
The output is a single TTL document containing one SHACL NodeShape per constraint.

What you must infer for each cccev:Constraint:
  1. Read its textual precondition from dct:description.
  2. Identify all constrained InformationConcepts.
  3. Read the concept descriptions.
  4. Infer which ontology classes, properties, and literal values must be queried to evaluate the constraint.
  5. Construct a SHACL NodeShape able to validate a single citizen instance.
This is the key intelligence step:
You must translate abstract concepts from the service graph into concrete navigable paths inside the Citizen Ontology.

Output rules:
Use the correct namespaces:
  @prefix : <http://example.org/schema#> .
  @prefix sh: <http://www.w3.org/ns/shacl#> .
  @prefix ex: <http://example.org/> .
Every generated shape must be a sh:NodeShape.
Every shape must target the root node: sh:targetNode :Applicant ;
Do not invent nodes and properties not present in the given ontology. Even if a constraint cannot be fully expressed by the available nodes, do it to the extent possible.
Use Property-Based Constraints when an InformationConcept corresponds directly to one literal reachable through simple property hops.
  Use sh:property blocks. Use: sh:path ex:predicate, sh:minCount, sh:datatype, sh:minInclusive / sh:maxInclusive, sh:pattern, sh:in etc.
Use SPARQL-Based Constraints when multiple information concepts must be combined, arithmetic is required (income thresholds, property sums), comparison of locations (city of residence vs. city of study),
  membership or boolean logic needed, involving multiple people (parents, children, household).
  Use sh:sparql constraints. Use SPARQL 1.1. 
  Do not embed a SELECT query inside a BIND clause; SPARQL does not allow sub-SELECT expressions inside BIND. All SELECT subqueries must stand as separate blocks in the WHERE clause.
  Never use property paths like / inside predicates. Instead create intermediate variables: ?this ex:has_income ?inc . ?inc ex:amount ?amt .
  Use ?this to denote the citizen instance.
  Provide a human-readable sh:message.
Return ONLY the output ttl. Return nothing else, including commentary.
  
Few-shot example:
Input snippet (Service Graph):
ex:family_income_threshold_condition a cccev:Constraint ;
  dct:description "The annual family income must not exceed €30,000, increased by €3,000 for each dependent child after the first." ;
  cccev:constrains ex:annual_family_income ;
  cccev:constrains ex:number_of_dependent_children .
ex:annual_family_income a cccev:InformationConcept ;
  dct:description "The total gross income of the family unit from the previous year." .
ex:number_of_dependent_children a cccev:InformationConcept ;
  dct:description "The number of financially dependent children." .

Input snippet (Citizen Ontology):
@prefix : <http://example.org/schema#> .
:Person a rdfs:Class .
:Parent a rdfs:Class ; rdfs:subClassOf :Person .
:Child a rdfs:Class ; rdfs:subClassOf :Person .
:Income a rdfs:Class .
:belongs_to_household a rdf:Property ; domain :Person ; range :Household .
:has_member a rdf:Property ; domain :Household ; range :Person .
:has_income a rdf:Property ; domain :Person ; range :Income .
:amount a rdf:Property ; domain :Income ; range xsd:decimal .
:has_child a rdf:Property ; domain :Parent ; range :Child .

Correct output shape (demonstration only):
ex:family_income_threshold_condition_shape
  a sh:NodeShape ;
  sh:targetNode :Applicant ;
  sh:sparql [
    a sh:SPARQLConstraint ;
    sh:message "Family income exceeds legal threshold." ;
    sh:select """
      SELECT ?this
      WHERE {
        ?this :belongs_to_household ?hh .
        {
          SELECT (SUM(?amt1) AS ?incApplicant)
          WHERE {
            ?this :has_income ?inc1 .
            ?inc1 :amount ?amt1 .
          }
        }
        {
          SELECT (SUM(?amt2) AS ?incParents)
          WHERE {
            ?hh :has_member ?parent .
            ?parent a :Parent .
            ?parent :has_income ?inc2 .
            ?inc2 :amount ?amt2 .
          }
        }
        {
          SELECT (COUNT(?child) AS ?numChildren)
          WHERE {
            ?hh :has_member ?child .
            ?child a :Child .
          }
        }
        BIND((?numChildren - 1) AS ?extra)
        BIND(IF(?extra < 0, 0, ?extra) AS ?extraChildren)
        BIND((30000 + (?extraChildren * 3000)) AS ?threshold)
        BIND((?incApplicant + ?incParents) AS ?totalIncome)
        FILTER(?totalIncome > ?threshold)
      }
    """ ;
  ] .
